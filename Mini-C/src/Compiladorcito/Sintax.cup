package Compiladorcito;

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.*;
import java.io.*;

parser code {:
    ArrayList gramas = new ArrayList();
    public Nodo raiz;
    public int cont = 0;
    public int maximo(){
    int a=5;
    return a;
}
    ArrayList errores=new ArrayList();
    public Symbol s;
    @Override
    public void syntax_error (Symbol s){
        if(s.left==-1){
        }else{
                errores.add("Syntax error en la línea: " + (s.left) + " , columna: " +(s.right)+ " con el símbolo = "+(s.value));
    }
}
    @Override
    public void unrecovered_syntax_error(Symbol s){
    if(s.left==-1){
    }else{
        errores.add("Error desconocido, por favor revise la linea: " + (s.left ) + " y columna:  " + (s.right )+ "Con simbolo: "+s.value);
    }    
    }
    public Symbol getS(){
        return this.s;
    }
:} ;



terminal tkn_opadicion,tkn_opmulti, tkn_break, tkn_opmod ;
terminal tkn_oprel ,tkn_main, tkn_intp, tkn_charp, tkn_void;
terminal tkn_if ,tkn_while, tkn_else,tkn_parentesisiz ,tkn_parentesisde ,tkn_llaveiz ,tkn_llaveder ; 
terminal tkn_and,tkn_or,tkn_for,tkn_return, tkn_printf, tkn_scanf, tkn_increment, tkn_decrement;
terminal tkn_dospuntos,tkn_int ,tkn_char, tkn_id, tkn_puntocoma, tkn_ternario, tkn_num, tkn_coma;
terminal tkn_ampersand, tkn_cadena, tkn_caracter;


non terminal Nodo WHILE, IF, FOR,CONDICION, ELSE, CONDICIONP, TIPO, CONTADOR, SCANF, FUNCION, PROTOTIPO, 
    PARAMS, ARGSPARAMS, ARGS, EXPR, ASIGN, ITERADOR, ASIGNACION, DECLASIGN;
non terminal Nodo INICIO,BLOQUE,PRINTF, PROGRAM, DECLR, PROTOFUN, TIPOAPUNT, TERNARIO;

precedence left tkn_opadicion;
precedence left tkn_opmulti, tkn_opmod;

start with INICIO;

INICIO::= PROGRAM:p
        {:
            parser.gramas.add("Inicio de programa reconocido");
            Nodo nodo = new Nodo("PROGRAMA",parser.cont);
            parser.cont++;
            nodo.addHijo(p);
            parser.raiz=nodo;
          :}
;

PROGRAM::= PROTOTIPO:t PROGRAM:p
           {:
                Nodo nodo = new Nodo("CUERPO",parser.cont);
                parser.cont++;
                nodo.addHijo(p);
                nodo.addHijo(t);
                RESULT=nodo;
            :}
          | FUNCION PROGRAM
          | ASIGN PROGRAM
;

PROTOTIPO::= PROTOFUN tkn_puntocoma
;

FUNCION::= PROTOFUN:p tkn_llaveiz BLOQUE:j tkn_return EXPR:e tkn_puntocoma tkn_llaveder
           {:parser.gramas.add("Una Funcion Reconocida satisfactoriamente");
                Nodo nodo = new Nodo("FUNCION",parser.cont);
                parser.cont++;
                nodo.addHijo(p);
                nodo.addHijo(j);
                nodo.addHijo(e);
                RESULT=nodo;
          :}
           | tkn_int tkn_main tkn_parentesisiz tkn_parentesisde tkn_llaveiz BLOQUE tkn_return EXPR tkn_puntocoma tkn_llaveder
           | PROTOFUN tkn_llaveiz BLOQUE tkn_return EXPR tkn_puntocoma error  {:parser.errores.add("Llave de cierre '}' ausente en la funcion\n");:}
           | PROTOFUN tkn_llaveiz BLOQUE tkn_return EXPR error tkn_llaveiz  {:parser.errores.add("Se esperaba un ';' en linea de retorno de la funcion\n");:}
          
;

PROTOFUN::= DECLR:d tkn_parentesisiz PARAMS:p tkn_parentesisde
            {:parser.gramas.add("Tipo de funcion reconocido");
                Nodo nodo = new Nodo("TIPO",parser.cont);
                parser.cont++;
                nodo.addHijo(d);
                nodo.addHijo(p);
                RESULT=nodo;
             :}
           | DECLR error PARAMS tkn_parentesisde {:parser.errores.add("Se esperaba un '(' en la funcion o prototipo\n");:}

;

DECLR::= TIPO:t tkn_id:k 
        {:
                Nodo nodo = new Nodo("DECLARACION",parser.cont);
                parser.cont++;
                nodo.addHijo(t.toString());
                nodo.addHijo(k.toString());
                RESULT=nodo;
        :}
         | error tkn_id {:parser.errores.add("Tipo de dato incorrecto\n");:}
;

ASIGNACION::= TIPO tkn_id tkn_oprel | tkn_id tkn_oprel | TIPO error tkn_oprel {:parser.errores.add("Se esperaba un identificador en bloque for\n");:}
;

DECLASIGN::= DECLR tkn_oprel EXPR tkn_coma DECLASIGN 
            | DECLR tkn_oprel EXPR
            | DECLR tkn_coma DECLASIGN 
            | tkn_id tkn_coma DECLASIGN
            | tkn_id error DECLASIGN {:parser.errores.add("Se esperaba el simbolo ',' en declaración o en argumentos en llamado de la función \n");:}
            | tkn_id tkn_oprel EXPR tkn_coma DECLASIGN 
            | tkn_id tkn_oprel EXPR
            | tkn_id error EXPR {:parser.errores.add("Se esperaba operador relacional en declaración \n");:}
            | DECLR 
            | DECLR tkn_oprel tkn_id tkn_parentesisiz ARGS tkn_parentesisde 
            | tkn_id tkn_oprel tkn_id tkn_parentesisiz ARGS tkn_parentesisde
            | DECLR tkn_oprel tkn_id tkn_parentesisiz error tkn_parentesisde {:parser.errores.add("Argumentos en llamado de función erroneos \n");:}
            | tkn_id tkn_oprel tkn_id tkn_parentesisiz error tkn_parentesisde {:parser.errores.add("Argumentos en llamado de función erroneos \n");:}
            | tkn_id tkn_parentesisiz ARGS tkn_parentesisde
            | tkn_id tkn_parentesisiz ARGS error {:parser.errores.add("Se esperaba un ')' en llamado de la funcion \n");:}
;


ASIGN::= DECLASIGN tkn_puntocoma |  error tkn_puntocoma {:parser.errores.add("Declaracion de variable incorrecta \n");:}
;

PARAMS::= TIPO tkn_coma PARAMS
          {:parser.gramas.add("Params reconocido");
                Nodo nodo = new Nodo("PARAMS",parser.cont);
                parser.cont++;
                RESULT=nodo;
          :}
         | DECLR tkn_coma PARAMS
         {:parser.gramas.add("Params reconocido");
                Nodo nodo = new Nodo("PARAMS",parser.cont);
                parser.cont++;
                RESULT=nodo;
          :}
         | DECLR
         {:parser.gramas.add("Params reconocido");
                Nodo nodo = new Nodo("PARAMS",parser.cont);
                parser.cont++;
                RESULT=nodo;
          :}
         | TIPO
         {:parser.gramas.add("Params reconocido");
                Nodo nodo = new Nodo("PARAMS",parser.cont);
                parser.cont++;
                RESULT=nodo;
          :}
         |
            {:
                Nodo node = new Nodo("EMPTYPARAMS",parser.cont);
                parser.cont++;
                node.addHijo(new Nodo("EMPTYPARAMS",parser.cont++));
                parser.cont++;
                RESULT = node;
            :}
;

TERNARIO ::= tkn_parentesisiz CONDICION tkn_parentesisde tkn_ternario tkn_cadena tkn_dospuntos tkn_cadena
;

IF::= tkn_if tkn_parentesisiz CONDICION:c tkn_parentesisde tkn_llaveiz BLOQUE:j tkn_llaveder ELSE 
         {:parser.gramas.add("Funcion if reconocida");
                Nodo nodo = new Nodo("IF",parser.cont);
                parser.cont++;
                nodo.addHijo(j);
                RESULT=nodo;
        :}  
     | tkn_if tkn_parentesisiz CONDICION tkn_parentesisde error BLOQUE tkn_llaveder ELSE {:parser.errores.add("Llave de apertura '{' ausente en bloque if\n");:}
     | tkn_if error CONDICION tkn_parentesisde tkn_llaveiz BLOQUE tkn_llaveder ELSE {:parser.errores.add("Se esperaba el simbolo '(' en bloque if\n");:}
     | tkn_if tkn_parentesisiz CONDICION error tkn_llaveiz BLOQUE tkn_llaveder ELSE {:parser.errores.add("Se esperaba el simbolo ')' en bloque if\n");:}
;

ELSE ::= tkn_else tkn_llaveiz BLOQUE tkn_llaveder
        | tkn_else IF
        | tkn_else error BLOQUE tkn_llaveder {:parser.errores.add("Se esperaba el simbolo '{' en else\n");:} 
        |
;

FOR ::= tkn_for tkn_parentesisiz ASIGNACION EXPR:e tkn_puntocoma CONDICION:c tkn_puntocoma tkn_id ITERADOR tkn_parentesisde tkn_llaveiz BLOQUE:j tkn_llaveder
        {:parser.gramas.add("Funcion FOR reconocida");
                Nodo nodo = new Nodo("FOR",parser.cont);
                parser.cont++;
                nodo.addHijo(e);
                nodo.addHijo(c);
                nodo.addHijo(j);
                RESULT=nodo;
        :}  
        | tkn_for error ASIGNACION EXPR tkn_puntocoma CONDICION tkn_puntocoma tkn_id ITERADOR tkn_parentesisde tkn_llaveiz BLOQUE tkn_llaveder {:parser.errores.add("Se esperaba un parentesis de apertura '(' for\n");:}
        | tkn_for tkn_parentesisiz ASIGNACION EXPR tkn_puntocoma CONDICION tkn_puntocoma tkn_id ITERADOR error tkn_llaveiz BLOQUE tkn_llaveder {:parser.errores.add("Se esperaba un parentesis de cierre ')' for\n");:}
        | tkn_for tkn_parentesisiz error EXPR tkn_puntocoma CONDICION tkn_puntocoma tkn_id ITERADOR tkn_parentesisde tkn_llaveiz BLOQUE tkn_llaveder {:parser.errores.add("Asignacion o declaracion incorrecta en bloque for\n");:}
        | tkn_for tkn_parentesisiz ASIGNACION EXPR tkn_puntocoma CONDICION tkn_puntocoma tkn_id error tkn_parentesisde tkn_llaveiz BLOQUE tkn_llaveder {:parser.errores.add("Iteracion asuente en ciclo for\n");:}
;

WHILE ::= tkn_while tkn_parentesisiz CONDICION:c tkn_parentesisde tkn_llaveiz BLOQUE:j tkn_llaveder
         {:parser.gramas.add("Funcion WHILE reconocida");
                Nodo nodo = new Nodo("WHILE",parser.cont);
                parser.cont++;
                nodo.addHijo(c);
                nodo.addHijo(j);
                RESULT=nodo;
         :}  
        | tkn_while tkn_parentesisiz CONDICION tkn_parentesisde error BLOQUE tkn_llaveder {:parser.errores.add("Se esperaba un '{' en bloque while\n");:}
        | tkn_while tkn_parentesisiz CONDICION error tkn_llaveiz BLOQUE tkn_llaveder {:parser.errores.add("Se esperaba un ')' en bloque while\n");:}
        | tkn_while error CONDICION tkn_parentesisde tkn_llaveiz BLOQUE tkn_llaveder {:parser.errores.add("Se esperaba un '(' en bloque while\n");:}
      
;

PRINTF ::= tkn_printf tkn_parentesisiz tkn_cadena tkn_coma tkn_id tkn_parentesisde tkn_puntocoma
           {:parser.gramas.add("Funcion PRINTF reconocida");
                Nodo nodo = new Nodo("PRINT F",parser.cont);
                parser.cont++;
                RESULT=nodo;
            :}
        |  tkn_printf tkn_parentesisiz tkn_cadena tkn_parentesisde tkn_puntocoma
            {:parser.gramas.add("Funcion PRINTF reconocida");
                Nodo nodo = new Nodo("PRINT F",parser.cont);
                parser.cont++;
                RESULT=nodo;
            :}
        |  tkn_printf tkn_parentesisiz tkn_cadena error tkn_id tkn_parentesisde tkn_puntocoma {:parser.errores.add("coma ',' ausente en la funcion printf");:}
        |  tkn_printf tkn_parentesisiz tkn_cadena tkn_coma error tkn_parentesisde tkn_puntocoma {:parser.errores.add("identificador ausente en la funcion printf");:}
        |  tkn_printf tkn_parentesisiz tkn_cadena tkn_coma tkn_id error tkn_puntocoma {:parser.errores.add("parentesis de cierre ')' ausente en la funcion printf");:}
        |  tkn_printf tkn_parentesisiz tkn_cadena tkn_coma tkn_id tkn_parentesisde error {:parser.errores.add("se esperaba el simbolo ';' en la funcion printf");:}
        |  tkn_printf error tkn_cadena tkn_coma tkn_id tkn_parentesisde tkn_puntocoma {:parser.errores.add("se esperaba el simbolo '(' en la funcion printf");:}
        |  tkn_printf tkn_parentesisiz error tkn_coma tkn_id tkn_parentesisde tkn_puntocoma {:parser.errores.add("conststr ausente en la funcion printf");:}

;

SCANF::= tkn_scanf tkn_parentesisiz tkn_cadena tkn_coma tkn_ampersand tkn_id tkn_parentesisde tkn_puntocoma
        {:parser.gramas.add("Funcion SCANF reconocida");
                Nodo nodo = new Nodo("SCANF",parser.cont);
                parser.cont++;
                RESULT=nodo;
        :}
         | tkn_scanf tkn_parentesisiz tkn_cadena tkn_coma error tkn_id tkn_parentesisde tkn_puntocoma {:parser.errores.add("Puntero a identificador '&' ausente en la funcion scanf");:}
         | tkn_scanf tkn_parentesisiz tkn_cadena tkn_coma tkn_ampersand error tkn_parentesisde tkn_puntocoma {:parser.errores.add("identificador ausente en la funcion scanf");:}
         | tkn_scanf tkn_parentesisiz tkn_cadena tkn_coma tkn_ampersand tkn_id error tkn_puntocoma {:parser.errores.add("parentesis de cierre ')' ausente en la funcion scanf");:}
         | tkn_scanf error tkn_cadena tkn_coma tkn_ampersand tkn_id tkn_parentesisde tkn_puntocoma {:parser.errores.add("parentesis de apertura '(' ausente en la funcion scanf");:}
         | tkn_scanf tkn_parentesisiz error tkn_coma tkn_ampersand tkn_id tkn_parentesisde tkn_puntocoma {:parser.errores.add("conststr ausente en la funcion scanf");:}

;

BLOQUE ::=  IF:i BLOQUE:s
            {:
                Nodo nodo = new Nodo("BLOQUE",parser.cont);
                parser.cont++;
                nodo.addHijo(i);
                nodo.addHijo(s);
                RESULT=nodo;
            :}
            | FOR:i BLOQUE:s
            {:
                Nodo nodo = new Nodo("BLOQUE",parser.cont);
                parser.cont++;
                nodo.addHijo(i);
                nodo.addHijo(s);
                RESULT=nodo;
            :}  
            | WHILE:i BLOQUE:s
            {:
                Nodo nodo = new Nodo("BLOQUE",parser.cont);
                parser.cont++;
                nodo.addHijo(i);
                nodo.addHijo(s);
                RESULT=nodo;
            :}  
            | ASIGN:i BLOQUE:s
            {:
                Nodo nodo = new Nodo("BLOQUE",parser.cont);
                parser.cont++;
                nodo.addHijo(i);
                nodo.addHijo(s);
                RESULT=nodo;
            :}  
            | SCANF:i BLOQUE:s
            {:
                Nodo nodo = new Nodo("BLOQUE",parser.cont);
                parser.cont++;
                nodo.addHijo(i);
                nodo.addHijo(s);
                RESULT=nodo;
            :}  
            | PRINTF:i BLOQUE:s
            {:
                Nodo nodo = new Nodo("BLOQUE",parser.cont);
                parser.cont++;
                nodo.addHijo(i);
                nodo.addHijo(s);
                RESULT=nodo;
            :}  
            | CONTADOR:i BLOQUE:s
            {:
                Nodo nodo = new Nodo("BLOQUE",parser.cont);
                parser.cont++;
                nodo.addHijo(i);
                nodo.addHijo(s);
                RESULT=nodo;
            :}  
            |
            {:
                Nodo node = new Nodo("VACIO",parser.cont);
                parser.cont++;
                node.addHijo(new Nodo("VACIO",parser.cont++));
                parser.cont++;
                RESULT = node;
            :}
            
;


ITERADOR::= tkn_increment
            |tkn_decrement
            | tkn_opadicion tkn_oprel EXPR
            | tkn_opmulti tkn_oprel EXPR

;

CONDICION ::= CONDICIONP tkn_and CONDICION
            | CONDICIONP tkn_or CONDICION
            | tkn_parentesisiz CONDICIONP tkn_parentesisde tkn_and CONDICION 
            | tkn_parentesisiz CONDICIONP tkn_parentesisde tkn_or CONDICION 
            | tkn_parentesisiz CONDICIONP tkn_parentesisde
            | CONDICIONP
            | error {:parser.errores.add("Operador relacional ausente en condicion");:}
            | error tkn_and CONDICION {:parser.errores.add("Expresion erronea o ausente en condicion");:}

;

CONDICIONP::= EXPR tkn_oprel EXPR

;

TIPO::= tkn_char
        |TIPOAPUNT
        |tkn_int
        |tkn_void
;


TIPOAPUNT ::= tkn_int tkn_opmulti
        | tkn_char tkn_opmulti
;

EXPR ::= EXPR tkn_opadicion EXPR
         {:parser.gramas.add("Expresiom reconocido");
                Nodo nodo = new Nodo("EXPR",parser.cont);
                parser.cont++;
                RESULT=nodo;
        :}

        | EXPR tkn_opmulti EXPR 
          {:parser.gramas.add("Expresiom reconocido");
                Nodo nodo = new Nodo("EXPR",parser.cont);
                parser.cont++;
                RESULT=nodo;
        :}
        | EXPR tkn_opmod EXPR 
          {:parser.gramas.add("Expresiom reconocido");
                Nodo nodo = new Nodo("EXPR",parser.cont);
                parser.cont++;
                RESULT=nodo;
        :}
        | tkn_parentesisiz EXPR tkn_parentesisde
          {:parser.gramas.add("Expresiom reconocido");
                Nodo nodo = new Nodo("EXPR",parser.cont);
                parser.cont++;
                RESULT=nodo;
        :}
        | tkn_id 
          {:parser.gramas.add("Expresiom reconocido");
                Nodo nodo = new Nodo("EXPR",parser.cont);
                parser.cont++;
                RESULT=nodo;
        :}
        | tkn_num
          {:parser.gramas.add("Expresiom reconocido");
                Nodo nodo = new Nodo("EXPR",parser.cont);
                parser.cont++;
                RESULT=nodo;
        :}
        | tkn_caracter 
          {:parser.gramas.add("Expresiom reconocido");
                Nodo nodo = new Nodo("EXPR",parser.cont);
                parser.cont++;
                RESULT=nodo;
        :}
        | error {:parser.errores.add("Expresión incorrecta");:}

;
ARGS::= ARGSPARAMS
        {:parser.gramas.add("Argumento reconocido");
                Nodo nodo = new Nodo("ARGS",parser.cont);
                parser.cont++;
                RESULT=nodo;
        :}
        |
        {:
        Nodo node = new Nodo("EMPTYARGS",parser.cont);
        parser.cont++;
        node.addHijo(new Nodo("EMPTYARGS",parser.cont++));
        parser.cont++;
        RESULT = node;
        :}
;

ARGSPARAMS ::= tkn_id tkn_coma ARGSPARAMS | tkn_id
;

CONTADOR ::= tkn_id ITERADOR tkn_puntocoma
             | tkn_id error tkn_puntocoma {:parser.errores.add("Iterador en identificador incorrecta");:}
;